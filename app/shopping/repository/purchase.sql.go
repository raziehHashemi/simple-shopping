// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: purchase.sql

package repository

import (
	"context"
	"database/sql"
)

const createPurchase = `-- name: CreatePurchase :one
INSERT INTO purchase (
  customer_id,
  product_id,
  count
) VALUES (
  $1, $2, $3
)
RETURNING id, customer_id, product_id, count, sold_at
`

type CreatePurchaseParams struct {
	CustomerID int64
	ProductID  sql.NullInt64
	Count      int32
}

func (q *Queries) CreatePurchase(ctx context.Context, arg CreatePurchaseParams) (Purchase, error) {
	row := q.db.QueryRowContext(ctx, createPurchase, arg.CustomerID, arg.ProductID, arg.Count)
	var i Purchase
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.ProductID,
		&i.Count,
		&i.SoldAt,
	)
	return i, err
}

const getPurchaseByCustomerId = `-- name: GetPurchaseByCustomerId :many
SELECT id, customer_id, product_id, count, sold_at FROM purchase
WHERE customer_id = $1 
ORDER BY id
`

func (q *Queries) GetPurchaseByCustomerId(ctx context.Context, customerID int64) ([]Purchase, error) {
	rows, err := q.db.QueryContext(ctx, getPurchaseByCustomerId, customerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Purchase
	for rows.Next() {
		var i Purchase
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.ProductID,
			&i.Count,
			&i.SoldAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPurchaseById = `-- name: GetPurchaseById :one
SELECT id, customer_id, product_id, count, sold_at FROM purchase
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetPurchaseById(ctx context.Context, id int64) (Purchase, error) {
	row := q.db.QueryRowContext(ctx, getPurchaseById, id)
	var i Purchase
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.ProductID,
		&i.Count,
		&i.SoldAt,
	)
	return i, err
}

const getPurchaseByProductId = `-- name: GetPurchaseByProductId :many
SELECT id, customer_id, product_id, count, sold_at FROM purchase
WHERE product_id = $1
ORDER BY id
`

func (q *Queries) GetPurchaseByProductId(ctx context.Context, productID sql.NullInt64) ([]Purchase, error) {
	rows, err := q.db.QueryContext(ctx, getPurchaseByProductId, productID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Purchase
	for rows.Next() {
		var i Purchase
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.ProductID,
			&i.Count,
			&i.SoldAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPurchases = `-- name: ListPurchases :many
SELECT id, customer_id, product_id, count, sold_at FROM purchase
ORDER BY id
`

func (q *Queries) ListPurchases(ctx context.Context) ([]Purchase, error) {
	rows, err := q.db.QueryContext(ctx, listPurchases)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Purchase
	for rows.Next() {
		var i Purchase
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.ProductID,
			&i.Count,
			&i.SoldAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
